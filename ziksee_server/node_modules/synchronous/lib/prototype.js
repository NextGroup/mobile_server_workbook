/*!
 * Synchronous
 * Copyright(c) 2011 Chris O'Hara <cohara87@gmail.com>
 * MIT Licensed
 */

// o_0

var __defineGetter__ = Object.__defineGetter__;
Object.prototype.__defineGetter__ = function (property, callback) {
    if (callback.length === 0) {
        return __defineGetter__.apply(this, arguments);
    }
    __defineGetter__.call(this, property, function () {
        var fiber = Fiber.current;
        callback(function (err, ret) {
            if (err) throw new Error(err);
            return fiber.run(ret);
        });
        return yield();
    });
}

var __defineSetter__ = Object.__defineSetter__;
Object.prototype.__defineSetter__ = function (property, callback) {
    if (callback.length === 1) {
        return __defineSetter__.apply(this, arguments);
    }
    __defineSetter__.call(this, property, function (value) {
        var fiber = Fiber.current;
        callback(value, function (err, ret) {
            if (err) throw new Error(err);
            return fiber.run(ret);
        });
        return yield();
    });
}

var defineProperty = Object.defineProperty;
Object.prototype.defineProperty = function (object, property, descriptor) {
    if (descriptor) {
        if ('get' in descriptor && descriptor.get.length === 1) {
            var get = descriptor.get;
            descriptor.get = function () {
                var fiber = Fiber.current;
                get(function (err, ret) {
                    if (err) throw new Error(err);
                    return fiber.run(ret);
                });
                return yield();
            }
        }
        if ('set' in descriptor && descriptor.set.length === 2) {
            var set = descriptor.set;
            descriptor.set = function (value) {
                var fiber = Fiber.current;
                set(value, function (err, ret) {
                    if (err) throw new Error(err);
                    return fiber.run(ret);
                });
                return yield();
            }
        }
    }
    return defineProperty.call(this, object, property, descriptor);
}

Function.prototype.sync = function () {
    var args = Array.prototype.slice.call(arguments)
      , fiber = Fiber.current
      , ret;
    args.push(function (err, result) {
        if (ret !== undefined) return;
        if (err) throw new Error(err);
        fiber.run(result);
    });
    ret = this.apply(this, args);
    return ret !== undefined ? ret : yield();
}

Object.prototype.syncMethod = function (method) {
    if (typeof this[method] !== 'function') {
        throw new Error(method + ' is not a function');
    }
    var original = this[method];
    return this[method] = original.sync.bind(original);
}

Object.prototype.syncSetter = function (method) {
    if (Array.isArray(method)) {
        var self = this;
        method.forEach(function (method) {
            self.syncSetter(method);
        });
        return;
    }
    if (typeof this[method] !== 'function') {
        throw new Error(method + ' is not a function');
    } else if (this[method].length !== 2) {
        throw new Error(method + ' must take (value, callback) as arguments');
    }
    var original = this[method];
    return this.defineProperty(this, method, {
        configurable: true,
        enumerable: true,
        set: function (value, callback) {
            return original.apply(this, arguments);
        }
    });
}

Object.prototype.syncGetter = function (method, cache_result) {
    var self = this;
    if (Array.isArray(method)) {
        method.forEach(function (method) {
            self.syncGetter(method, cache_result);
        });
        return;
    }
    if (typeof this[method] !== 'function') {
        throw new Error(method + ' is not a function');
    } else if (this[method].length !== 1) {
        throw new Error(method + ' must take one (callback) argument');
    }
    var original = this[method];
    return this.defineProperty(this, method, {
        configurable: true,
        enumerable: true,
        get: function (callback) {
            original.call(this, function (err, result) {
                if (err) return callback(err, null);
                if (cache_result) {
                    delete self[method];
                    self[method] = result;
                }
                callback(null, result);
            });
        }
    });
}
